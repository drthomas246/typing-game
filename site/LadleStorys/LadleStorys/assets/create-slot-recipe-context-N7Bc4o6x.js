import{r as c,m as re,B as ne,C as se,D as oe,M as _,I,k as K,E as ce,F as A,G as Y,H as ue,J as ae,K as ie,L as fe,N as J,j as T,i as G}from"./index-DvxvgMDz.js";import{c as H,m as Q,E as le}from"./h-stack-CM-3ku_d.js";function de(e,r){return`${e} returned \`undefined\`. Seems you forgot to wrap component within ${r}`}function Z(e={}){const{name:r,strict:o=!0,hookName:t="useContext",providerName:a="Provider",errorMessage:f,defaultValue:m}=e,d=c.createContext(m);d.displayName=r;function R(){var j;const E=c.useContext(d);if(!E&&o){const y=new Error(f??de(t,a));throw y.name="ContextError",(j=Error.captureStackTrace)==null||j.call(Error,y,R),y}return E}return[d.Provider,R,d]}const[Ee,Pe]=Z({name:"EnvironmentContext",hookName:"useEnvironmentContext",providerName:"<EnvironmentProvider />",strict:!1,defaultValue:{getRootNode:()=>document,getDocument:()=>document,getWindow:()=>window}});function pe(...e){return r=>{const o=[];for(const t of e)if(typeof t=="function"){const a=t(r);typeof a=="function"&&o.push(a)}else t&&(t.current=r);if(o.length)return()=>{for(const t of o)t()}}}function ge(e){var t,a;let r=(t=Object.getOwnPropertyDescriptor(e.props,"ref"))==null?void 0:t.get,o=r&&"isReactWarning"in r&&r.isReactWarning;return o?e.ref:(r=(a=Object.getOwnPropertyDescriptor(e,"ref"))==null?void 0:a.get,o=r&&"isReactWarning"in r&&r.isReactWarning,o?e.props.ref:e.props.ref||e.ref)}const B=e=>{const r=c.memo(c.forwardRef((o,t)=>{const{asChild:a,children:f,...m}=o;if(!a)return c.createElement(e,{...m,ref:t},f);if(!c.isValidElement(f))return null;const d=c.Children.only(f),R=ge(d);return c.cloneElement(d,{...re(m,d.props),ref:t?pe(t,R):R})}));return r.displayName=e.displayName||e.name,r},me=()=>{const e=new Map;return new Proxy(B,{apply(r,o,t){return B(t[0])},get(r,o){const t=o;return e.has(t)||e.set(t,B(t)),e.get(t)}})},he=me(),[we,Me]=Z({name:"LocaleContext",hookName:"useLocaleContext",providerName:"<LocaleProvider />",strict:!1,defaultValue:{dir:"ltr",locale:"en-US"}}),je=()=>(e,r)=>r.reduce((o,t)=>{const[a,f]=o,m=t;return f[m]!==void 0&&(a[m]=f[m]),delete f[m],[a,f]},[{},{...e}]);var ee=typeof globalThis.document<"u"?c.useLayoutEffect:c.useEffect;function U(e){const r=e().value??e().defaultValue,o=e().isEqual??Object.is,[t]=c.useState(r),[a,f]=c.useState(t),m=e().value!==void 0,d=c.useRef(a);d.current=m?e().value:a;const R=c.useRef(d.current);ee(()=>{R.current=d.current},[a,e().value]);const E=y=>{var p,x;const N=R.current,S=A(y)?y(N):y;e().debug&&console.log(`[bindable > ${e().debug}] setValue`,{next:S,prev:N}),m||f(S),o(S,N)||(x=(p=e()).onChange)==null||x.call(p,S,N)};function j(){return m?e().value:a}return{initial:t,ref:d,get:j,set(y){(e().sync?K.flushSync:ce)(()=>E(y))},invoke(y,N){var S,p;(p=(S=e()).onChange)==null||p.call(S,y,N)},hash(y){var N,S;return((S=(N=e()).hash)==null?void 0:S.call(N,y))??String(y)}}}U.cleanup=e=>{c.useEffect(()=>e,[])};U.ref=e=>{const r=c.useRef(e);return{get:()=>r.current,set:o=>{r.current=o}}};function ye(e){const r=c.useRef(e);return{get(o){return r.current[o]},set(o,t){r.current[o]=t}}}var xe=(e,r)=>{const o=c.useRef(!1),t=c.useRef(!1);c.useEffect(()=>{if(o.current&&t.current)return r();t.current=!0},[...(e??[]).map(a=>typeof a=="function"?a():a)]),c.useEffect(()=>(o.current=!0,()=>{o.current=!1}),[])};function $e(e,r={}){var q,F,z,W;const o=c.useMemo(()=>{const{id:s,ids:n,getRootNode:u}=r;return ne({id:s,ids:n,getRootNode:u})},[r]),t=(...s)=>{e.debug&&console.log(...s)},a=((q=e.props)==null?void 0:q.call(e,{props:se(r),scope:o}))??r,f=ve(a),m=(F=e.context)==null?void 0:F.call(e,{prop:f,bindable:U,scope:o,flush:X,getContext(){return R},getComputed(){return b},getRefs(){return x},getEvent(){return S()}}),d=te(m),R={get(s){var n;return(n=d.current)==null?void 0:n[s].ref.current},set(s,n){var u;(u=d.current)==null||u[s].set(n)},initial(s){var n;return(n=d.current)==null?void 0:n[s].initial},hash(s){var u,i;const n=(u=d.current)==null?void 0:u[s].get();return(i=d.current)==null?void 0:i[s].hash(n)}},E=c.useRef(new Map),j=c.useRef(null),y=c.useRef(null),N=c.useRef({type:""}),S=()=>({...N.current,current(){return N.current},previous(){return y.current}}),p=()=>({...C,matches(...s){return s.includes(C.ref.current)},hasTag(s){var n,u;return!!((u=(n=e.states[C.ref.current])==null?void 0:n.tags)!=null&&u.includes(s))}}),x=ye(((z=e.refs)==null?void 0:z.call(e,{prop:f,context:R}))??{}),l=()=>({state:p(),context:R,event:S(),prop:f,send:D,action:g,guard:w,track:xe,refs:x,computed:b,flush:X,scope:o,choose:V}),g=s=>{const n=A(s)?s(l()):s;if(!n)return;const u=n.map(i=>{var h,k;const v=(k=(h=e.implementations)==null?void 0:h.actions)==null?void 0:k[i];return v||Y(`[zag-js] No implementation found for action "${JSON.stringify(i)}"`),v});for(const i of u)i==null||i(l())},w=s=>{var n,u;return A(s)?s(l()):(u=(n=e.implementations)==null?void 0:n.guards)==null?void 0:u[s](l())},M=s=>{const n=A(s)?s(l()):s;if(!n)return;const u=n.map(v=>{var k,$;const h=($=(k=e.implementations)==null?void 0:k.effects)==null?void 0:$[v];return h||Y(`[zag-js] No implementation found for effect "${JSON.stringify(v)}"`),h}),i=[];for(const v of u){const h=v==null?void 0:v(l());h&&i.push(h)}return()=>i.forEach(v=>v==null?void 0:v())},V=s=>ue(s).find(n=>{let u=!n.guard;return ae(n.guard)?u=!!w(n.guard):A(n.guard)&&(u=n.guard(l())),u}),b=s=>{oe(e.computed,()=>"[zag-js] No computed object found on machine");const n=e.computed[s];return n({context:R,event:S(),prop:f,refs:x,scope:o,computed:b})},C=U(()=>({defaultValue:e.initialState({prop:f}),onChange(s,n){var i,v,h,k;if(n){const $=E.current.get(n);$==null||$(),E.current.delete(n)}n&&g((i=e.states[n])==null?void 0:i.exit),g((v=j.current)==null?void 0:v.actions);const u=M((h=e.states[s])==null?void 0:h.effects);if(u&&E.current.set(s,u),n===I){g(e.entry);const $=M(e.effects);$&&E.current.set(I,$)}g((k=e.states[s])==null?void 0:k.entry)}})),L=c.useRef(void 0),P=c.useRef(_.NotStarted);ee(()=>{queueMicrotask(()=>{const u=P.current===_.Started;P.current=_.Started,t(u?"rehydrating...":"initializing...");const i=L.current??C.initial;C.invoke(i,u?C.get():I)});const s=E.current,n=C.ref.current;return()=>{t("unmounting..."),L.current=n,P.current=_.Stopped,s.forEach(u=>u==null?void 0:u()),E.current=new Map,j.current=null,queueMicrotask(()=>{g(e.exit)})}},[]);const O=()=>"ref"in C?C.ref.current:C.get(),D=s=>{queueMicrotask(()=>{var k,$;if(P.current!==_.Started)return;y.current=N.current,N.current=s;let n=O();const u=((k=e.states[n].on)==null?void 0:k[s.type])??(($=e.on)==null?void 0:$[s.type]),i=V(u);if(!i)return;j.current=i;const v=i.target??n;t("transition",s.type,i.target||n,`(${i.actions})`);const h=v!==n;h?K.flushSync(()=>C.set(v)):i.reenter&&!h?C.invoke(n,n):g(i.actions??[])})};return(W=e.watch)==null||W.call(e,l()),{state:p(),send:D,context:R,prop:f,scope:o,refs:x,computed:b,event:S(),getStatus:()=>P.current}}function te(e){const r=c.useRef(e);return r.current=e,r}function ve(e){const r=te(e);return function(t){return r.current[t]}}function X(e){queueMicrotask(()=>{K.flushSync(()=>e())})}var be=ie(e=>e);function Ce(e){const{key:r,recipe:o}=e,t=fe();return c.useMemo(()=>{const a=o||(r!=null?t.getSlotRecipe(r):{});return t.sva(structuredClone(a))},[r,o,t])}const Re=e=>e.charAt(0).toUpperCase()+e.slice(1),ke=e=>{const{key:r,recipe:o}=e,t=Re(r||o.className||"Component"),[a,f]=J({name:`${t}StylesContext`,errorMessage:`use${t}Styles returned is 'undefined'. Seems you forgot to wrap the components in "<${t}.Root />" `}),[m,d]=J({name:`${t}ClassNameContext`,errorMessage:`use${t}ClassNames returned is 'undefined'. Seems you forgot to wrap the components in "<${t}.Root />" `,strict:!1}),[R,E]=J({strict:!1,name:`${t}PropsContext`,providerName:`${t}PropsContext`,defaultValue:{}});function j(p){const{unstyled:x,...l}=p,g=Ce({key:r,recipe:l.recipe||o}),[w,M]=c.useMemo(()=>g.splitVariantProps(l),[l,g]);return{styles:c.useMemo(()=>x?le:g(w),[x,w,g]),classNames:g.classNameMap,props:M}}function y(p,x={}){const{defaultProps:l}=x,g=w=>{const M=E(),V=c.useMemo(()=>Q(l,M,w),[M,w]),{styles:b,classNames:C,props:L}=j(V);return T.jsx(a,{value:b,children:T.jsx(m,{value:C,children:T.jsx(p,{...L})})})};return g.displayName=p.displayName||p.name,g}return{StylesProvider:a,ClassNamesProvider:m,PropsProvider:R,usePropsContext:E,useRecipeResult:j,withProvider:(p,x,l)=>{const{defaultProps:g,...w}=l??{},M=H(p,{},w),V=c.forwardRef((b,C)=>{var W;const L=E(),P=c.useMemo(()=>Q(g??{},L,b),[L,b]),{styles:O,props:D,classNames:q}=j(P),F=q[x],z=T.jsx(a,{value:O,children:T.jsx(m,{value:q,children:T.jsx(M,{ref:C,...D,css:[O[x],P.css],className:G(P.className,F)})})});return((W=l==null?void 0:l.wrapElement)==null?void 0:W.call(l,z,P))??z});return V.displayName=p.displayName||p.name,V},withContext:(p,x,l)=>{const g=H(p,{},l),w=c.forwardRef((M,V)=>{const{unstyled:b,...C}=M,L=f(),P=d(),O=P==null?void 0:P[x];return T.jsx(g,{...C,css:[!b&&x?L[x]:void 0,M.css],ref:V,className:G(M.className,O)})});return w.displayName=p.displayName||p.name,w},withRootProvider:y,useStyles:f,useClassNames:d}};export{he as a,je as b,Z as c,pe as d,Me as e,$e as f,ke as g,Ce as h,be as n,Pe as u};
